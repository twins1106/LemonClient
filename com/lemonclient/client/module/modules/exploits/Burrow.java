//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\user\¹ÙÅÁ È­¸é\map"!

//Decompiled by Procyon!

package com.lemonclient.client.module.modules.exploits;

import com.lemonclient.client.module.*;
import com.lemonclient.api.setting.values.*;
import java.util.*;
import net.minecraft.entity.player.*;
import net.minecraft.network.*;
import net.minecraft.client.settings.*;
import com.lemonclient.api.util.world.*;
import com.lemonclient.api.util.player.*;
import net.minecraft.init.*;
import net.minecraft.entity.*;
import net.minecraft.block.*;
import net.minecraft.util.math.*;
import net.minecraft.util.*;
import net.minecraft.network.play.client.*;

@Module.Declaration(name = "Burrow", category = Category.Exploits, priority = 101)
public class Burrow extends Module
{
    boolean finishOnGround;
    boolean materials;
    boolean center;
    boolean havePhase;
    boolean beforeShiftJump;
    BooleanSetting allowEchest;
    BooleanSetting onlyEchest;
    BooleanSetting allowAnvil;
    BooleanSetting onlyAnvil;
    BooleanSetting instaActive;
    BooleanSetting disactiveAfter;
    BooleanSetting alwaysActive;
    BooleanSetting onShift;
    BooleanSetting preRotate;
    ModeSetting jumpMode;
    BooleanSetting doubleRubberband;
    DoubleSetting addDouble;
    BooleanSetting beforeRubberband;
    ModeSetting rubberbandMode;
    IntegerSetting ym;
    IntegerSetting yp;
    IntegerSetting minY;
    IntegerSetting yStart;
    IntegerSetting maxStartY;
    IntegerSetting maxFinishY;
    IntegerSetting addY;
    BooleanSetting onPlayer;
    DoubleSetting rangePlayer;
    BooleanSetting phase;
    BooleanSetting predictPhase;
    ModeSetting phaseRubberband;
    IntegerSetting phaseAddY;
    BooleanSetting scaffold;
    BooleanSetting shiftJump;
    BooleanSetting safeMode;
    BooleanSetting normalSwitch;
    BooleanSetting switchBack;
    IntegerSetting tickSwitchBack;
    int tick;
    int oldSlotBack;
    
    public Burrow() {
        this.allowEchest = this.registerBoolean("Allow Echest", true);
        this.onlyEchest = this.registerBoolean("Only Echest", false);
        this.allowAnvil = this.registerBoolean("Allow Anvil", true);
        this.onlyAnvil = this.registerBoolean("Only Anvil", false);
        this.instaActive = this.registerBoolean("Insta Active", true);
        this.disactiveAfter = this.registerBoolean("Insta disactive", true);
        this.alwaysActive = this.registerBoolean("Always Active", false);
        this.onShift = this.registerBoolean("On Shift", true);
        this.preRotate = this.registerBoolean("Pre Rotate", false);
        this.jumpMode = this.registerMode("Jump Mode", (List)Arrays.asList("Konas", "Future"), "Konas");
        this.doubleRubberband = this.registerBoolean("Double Rubberband", false);
        this.addDouble = this.registerDouble("Add Double", 1.1, 0.0, 2.0);
        this.beforeRubberband = this.registerBoolean("Before Rubberband", false);
        this.rubberbandMode = this.registerMode("Rubberband Mode", (List)Arrays.asList("+Y", "-Y", "Add Y", "Free Y"), "+Y");
        this.ym = this.registerInteger("Y-", -4, -64, 0);
        this.yp = this.registerInteger("Y+", 128, 0, 200);
        this.minY = this.registerInteger("Min Y", 9, 0, 30);
        this.yStart = this.registerInteger("Min Y Start", -9, 0, -20);
        this.maxStartY = this.registerInteger("Max Start Y", 8, 5, 20);
        this.maxFinishY = this.registerInteger("Max Finish Y", 15, 10, 40);
        this.addY = this.registerInteger("Rub Add Y", 10, -40, 40);
        this.onPlayer = this.registerBoolean("On Player", false);
        this.rangePlayer = this.registerDouble("Range Player", 3.0, 0.0, 4.0);
        this.phase = this.registerBoolean("Phase", false);
        this.predictPhase = this.registerBoolean("Predict Phase", false);
        this.phaseRubberband = this.registerMode("Phase Rubberband", (List)Arrays.asList("Y+", "Y-", "Y0", "AddY", "X", "Z", "XZ"), "Y+");
        this.phaseAddY = this.registerInteger("Phase Add Y", 40, -40, 40);
        this.scaffold = this.registerBoolean("Scaffold", false);
        this.shiftJump = this.registerBoolean("Shift Jump", false);
        this.safeMode = this.registerBoolean("Safe Mode", false);
        this.normalSwitch = this.registerBoolean("Normal Switch", false);
        this.switchBack = this.registerBoolean("Switch Back", false);
        this.tickSwitchBack = this.registerInteger("Tick SwitchBack", 4, 0, 10);
    }
    
    public void onEnable() {
        this.initValues();
        if (this.instaActive.getValue()) {
            this.instaBurrow((boolean)this.disactiveAfter.getValue());
        }
    }
    
    void initValues() {
        final boolean b = false;
        this.beforeShiftJump = b;
        this.havePhase = b;
        this.center = b;
        this.finishOnGround = b;
        this.materials = true;
        final int n = -1;
        this.tick = n;
        this.oldSlotBack = n;
    }
    
    public void onUpdate() {
        if (this.tick != -1 && this.tick++ >= (int)this.tickSwitchBack.getValue()) {
            Burrow.mc.player.inventory.currentItem = this.oldSlotBack;
            final int n = -1;
            this.tick = n;
            this.oldSlotBack = n;
        }
        if (this.havePhase) {
            this.doPhase();
            this.havePhase = false;
            if (this.disactiveAfter.getValue()) {
                this.disable();
            }
        }
        if (((boolean)this.onShift.getValue() && Burrow.mc.player.isSneaking()) || (boolean)this.alwaysActive.getValue() || this.finishOnGround || ((boolean)this.onPlayer.getValue() && PlayerUtil.findClosestTarget((double)this.rangePlayer.getValue(), (EntityPlayer)null) != null)) {
            this.instaBurrow((boolean)this.disactiveAfter.getValue());
        }
        if ((boolean)this.shiftJump.getValue() && Burrow.mc.gameSettings.keyBindJump.isKeyDown() && Burrow.mc.gameSettings.keyBindSneak.isKeyDown() && !this.beforeShiftJump) {
            Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, Math.floor(Burrow.mc.player.posY) + 1.0, Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
            Burrow.mc.player.setPosition(Burrow.mc.player.posX, Math.floor(Burrow.mc.player.posY) + 1.0, Burrow.mc.player.posZ);
            KeyBinding.setKeyBindState(Burrow.mc.gameSettings.keyBindJump.getKeyCode(), false);
        }
        if (this.center) {
            PlayerUtil.centerPlayer(BlockUtil.getCenterOfBlock(Burrow.mc.player.posX, Burrow.mc.player.posY, Burrow.mc.player.posZ));
            this.center = false;
        }
    }
    
    public void onDisable() {
        if (this.materials) {
            this.setDisabledMessage("No materials found... Burrow disabled");
        }
    }
    
    void instaBurrow(final boolean disactive) {
        if (Burrow.mc.player.onGround) {
            int slotBlock = this.onlyEchest.getValue() ? -1 : (this.onlyAnvil.getValue() ? -1 : InventoryUtil.findObsidianSlot(false, false));
            if (slotBlock == -1) {
                if (this.allowEchest.getValue()) {
                    slotBlock = InventoryUtil.findFirstBlockSlot((Class)Blocks.ENDER_CHEST.getClass(), 0, 8);
                }
                if (this.allowAnvil.getValue()) {
                    slotBlock = InventoryUtil.findFirstBlockSlot((Class)Blocks.ANVIL.getClass(), 0, 8);
                }
            }
            if (slotBlock == -1) {
                this.materials = false;
                this.disable();
                return;
            }
            final double posY = (Burrow.mc.player.posY % 1.0 >= 0.5) ? ((double)Math.round(Burrow.mc.player.posY)) : Burrow.mc.player.posY;
            final BlockPos pos = new BlockPos(Burrow.mc.player.posX, posY, Burrow.mc.player.posZ);
            if (!Burrow.mc.world.getBlockState(pos).getMaterial().isReplaceable() || Burrow.mc.world.getEntitiesWithinAABBExcludingEntity((Entity)null, new AxisAlignedBB(pos)).stream().anyMatch(entity -> entity instanceof EntityPlayer && entity != Burrow.mc.player)) {
                if (!(boolean)this.alwaysActive.getValue()) {
                    this.disable();
                }
                return;
            }
            boolean scaf = false;
            if (BlockUtil.getBlock(pos.add(0, -1, 0)) instanceof BlockAir) {
                if (!(boolean)this.scaffold.getValue()) {
                    if (!(boolean)this.alwaysActive.getValue()) {
                        this.disable();
                    }
                    return;
                }
                scaf = true;
            }
            if (!(BlockUtil.getBlock(pos.add(0, 2, 0)) instanceof BlockAir)) {
                return;
            }
            if (this.preRotate.getValue()) {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Rotation(0.0f, 90.0f, true));
            }
            int y = Integer.MIN_VALUE;
            if (((String)this.rubberbandMode.getValue()).equals("Free Y")) {
                boolean bottom = BlockUtil.getBlock(Burrow.mc.player.posX, Burrow.mc.player.posY - (int)this.minY.getValue(), Burrow.mc.player.posZ) instanceof BlockAir;
                for (int i = (int)this.minY.getValue() - 1; i > -1; --i) {
                    final boolean air = BlockUtil.getBlock(Burrow.mc.player.posX, Burrow.mc.player.posY - i, Burrow.mc.player.posZ) instanceof BlockAir;
                    if (Burrow.mc.player.posY - i >= (int)this.yStart.getValue()) {
                        if (bottom && air) {
                            y = -i;
                            break;
                        }
                        bottom = air;
                    }
                }
                if (y == Integer.MIN_VALUE) {
                    bottom = (BlockUtil.getBlock(Burrow.mc.player.posX, Burrow.mc.player.posY + (int)this.maxStartY.getValue(), Burrow.mc.player.posZ) instanceof BlockAir);
                    for (int i = (int)this.maxStartY.getValue() + 1; i < (int)this.maxFinishY.getValue(); ++i) {
                        final boolean air = BlockUtil.getBlock(Burrow.mc.player.posX, Burrow.mc.player.posY + y, Burrow.mc.player.posZ) instanceof BlockAir;
                        if (bottom && air) {
                            y = i;
                            break;
                        }
                        bottom = air;
                    }
                    if (y == Integer.MIN_VALUE) {
                        return;
                    }
                }
            }
            double posX = Burrow.mc.player.posX;
            double posZ = Burrow.mc.player.posZ;
            final Vec3d newPos = BlockUtil.getCenterOfBlock(posX, Burrow.mc.player.posY, posZ);
            final int oldSlot = Burrow.mc.player.inventory.currentItem;
            if (!Burrow.mc.world.getCollisionBoxes((Entity)Burrow.mc.player, Burrow.mc.player.getEntityBoundingBox()).isEmpty() || (boolean)this.safeMode.getValue()) {
                final double distance;
                if ((distance = Burrow.mc.player.getDistanceSq(newPos.x, Burrow.mc.player.posY, newPos.z)) > 0.1) {
                    if (scaf) {
                        if (slotBlock != oldSlot) {
                            Burrow.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(slotBlock));
                            if (this.normalSwitch.getValue()) {
                                Burrow.mc.player.inventory.currentItem = slotBlock;
                            }
                        }
                        this.placeBlockPacket(null, pos.add(0, -1, 0));
                    }
                    this.finishOnGround = true;
                    Burrow.mc.player.motionX = 0.0;
                    Burrow.mc.player.motionZ = 0.0;
                    final double newX = posX + (newPos.x - posX) / 2.0;
                    final double newZ = posZ + (newPos.z - posZ) / 2.0;
                    Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(newX, Burrow.mc.player.posY, newZ, true));
                    Burrow.mc.player.setPosition(newX, Burrow.mc.player.posY, newZ);
                    if (slotBlock != oldSlot) {
                        if (this.normalSwitch.getValue()) {
                            if (this.switchBack.getValue()) {
                                this.oldSlotBack = oldSlot;
                                this.tick = 0;
                            }
                        }
                        else {
                            Burrow.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(Burrow.mc.player.inventory.currentItem));
                        }
                    }
                    return;
                }
                if ((boolean)this.safeMode.getValue() && distance > 0.05) {
                    if (scaf) {
                        if (slotBlock != oldSlot) {
                            if (this.normalSwitch.getValue()) {
                                Burrow.mc.player.inventory.currentItem = slotBlock;
                            }
                            Burrow.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(slotBlock));
                        }
                        this.placeBlockPacket(null, pos.add(0, -1, 0));
                    }
                    this.center = true;
                    if (slotBlock != oldSlot) {
                        if (this.normalSwitch.getValue()) {
                            if (this.switchBack.getValue()) {
                                this.oldSlotBack = oldSlot;
                                this.tick = 0;
                            }
                        }
                        else {
                            Burrow.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(Burrow.mc.player.inventory.currentItem));
                        }
                    }
                    return;
                }
            }
            posX = newPos.x;
            posZ = newPos.z;
            boolean isSneaking = false;
            if (BlockUtil.canBeClicked(pos.add(0, -1, 0)) && !Burrow.mc.player.isSneaking()) {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketEntityAction((Entity)Burrow.mc.player, CPacketEntityAction.Action.START_SNEAKING));
                isSneaking = true;
            }
            if (slotBlock != oldSlot) {
                if (this.normalSwitch.getValue()) {
                    Burrow.mc.player.inventory.currentItem = slotBlock;
                }
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(slotBlock));
            }
            if (scaf) {
                this.placeBlockPacket(null, pos.add(0, -1, 0));
            }
            this.jump((String)this.jumpMode.getValue(), posX, posZ);
            this.placeBlockPacket(EnumFacing.DOWN, pos);
            double newY = -4.0;
            final String s = (String)this.rubberbandMode.getValue();
            switch (s) {
                case "+Y": {
                    newY = (int)this.yp.getValue();
                    break;
                }
                case "-Y": {
                    newY = (int)this.ym.getValue();
                    break;
                }
                case "Add Y": {
                    newY = posY + (int)this.addY.getValue();
                    break;
                }
                case "Free Y": {
                    newY = posY + y;
                    break;
                }
            }
            if (this.beforeRubberband.getValue()) {
                this.rubberband(posX, newY, posZ);
            }
            if (slotBlock != oldSlot) {
                if (this.normalSwitch.getValue()) {
                    if (this.switchBack.getValue()) {
                        this.oldSlotBack = oldSlot;
                        this.tick = 0;
                    }
                }
                else {
                    Burrow.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(oldSlot));
                }
            }
            if (isSneaking) {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketEntityAction((Entity)Burrow.mc.player, CPacketEntityAction.Action.STOP_SNEAKING));
            }
            if (!(boolean)this.beforeRubberband.getValue()) {
                this.rubberband(posX, newY, posZ);
            }
            if (this.phase.getValue()) {
                if (this.predictPhase.getValue()) {
                    this.doPhase();
                }
                this.havePhase = true;
            }
        }
        else {
            this.finishOnGround = true;
        }
        if (disactive && !(boolean)this.phase.getValue()) {
            this.disable();
        }
    }
    
    void rubberband(final double posX, final double newY, final double posZ) {
        Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, newY, posZ, true));
        if (this.doubleRubberband.getValue()) {
            Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, newY + (double)this.addDouble.getValue(), posZ, true));
        }
    }
    
    void jump(final String mode, final double posX, final double posZ) {
        switch (mode) {
            case "Konas": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 0.42, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 0.75, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 1.01, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 1.16, posZ, true));
                break;
            }
            case "Future": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 0.42, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 0.75, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 0.9, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 1.17, posZ, true));
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(posX, Burrow.mc.player.posY + 1.17, posZ, true));
                break;
            }
        }
    }
    
    boolean placeBlockPacket(EnumFacing side, final BlockPos pos) {
        if (side == null) {
            side = BlockUtil.getPlaceableSide(pos);
        }
        if (side == null) {
            return false;
        }
        final BlockPos neighbour = pos.offset(side);
        final EnumFacing opposite = side.getOpposite();
        final Vec3d vec = new Vec3d((Vec3i)neighbour).add(0.5, 0.5, 0.5).add(new Vec3d(opposite.getDirectionVec()).scale(0.5));
        final float f = (float)(vec.x - pos.getX());
        final float f2 = (float)(vec.y - pos.getY());
        final float f3 = (float)(vec.z - pos.getZ());
        Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayerTryUseItemOnBlock(neighbour, opposite, EnumHand.MAIN_HAND, f, f2, f3));
        Burrow.mc.player.swingArm(EnumHand.MAIN_HAND);
        return true;
    }
    
    void doPhase() {
        Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, Burrow.mc.player.posY - 0.03125, Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
        final String s = (String)this.phaseRubberband.getValue();
        switch (s) {
            case "Y+": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, 1000.0, Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
            case "Y-": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, -1000.0, Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
            case "Y0": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, 0.0, Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
            case "AddY": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, Burrow.mc.player.posY + (int)this.phaseAddY.getValue(), Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
            case "X": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX + 75.0, Burrow.mc.player.posY, Burrow.mc.player.posZ, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
            case "Z": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX, Burrow.mc.player.posY, Burrow.mc.player.posZ + 75.0, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
            case "XZ": {
                Burrow.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(Burrow.mc.player.posX + 75.0, Burrow.mc.player.posY, Burrow.mc.player.posZ + 75.0, Burrow.mc.player.rotationYaw, Burrow.mc.player.rotationPitch, Burrow.mc.player.onGround));
                break;
            }
        }
    }
}
