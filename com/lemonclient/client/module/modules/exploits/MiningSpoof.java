//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\user\πŸ≈¡ »≠∏È\map"!

//Decompiled by Procyon!

package com.lemonclient.client.module.modules.exploits;

import com.lemonclient.client.module.*;
import com.lemonclient.api.setting.values.*;
import me.zero.alpine.listener.*;
import java.util.function.*;
import net.minecraft.block.*;
import net.minecraft.item.*;
import net.minecraft.init.*;
import net.minecraft.world.*;
import net.minecraft.client.*;
import com.lemonclient.api.event.events.*;
import net.minecraft.network.play.server.*;
import net.minecraft.util.*;
import com.lemonclient.api.util.player.*;
import net.minecraft.network.*;
import net.minecraft.network.play.client.*;
import net.minecraft.util.math.*;

@Module.Declaration(name = "MiningSpoof", category = Category.Exploits)
public class MiningSpoof extends Module
{
    boolean noPick;
    BooleanSetting ignoreAxe;
    BooleanSetting ignoreSword;
    @EventHandler
    private final Listener<PlayerMoveEvent> eventListener;
    @EventHandler
    private final Listener<DamageBlockEvent> playerDamageBlockEvent;
    
    public MiningSpoof() {
        this.ignoreAxe = this.registerBoolean("IgnoreAxe", false);
        this.ignoreSword = this.registerBoolean("IgnoreSword", false);
        this.eventListener = (Listener<PlayerMoveEvent>)new Listener(event -> {
            if (MiningSpoof.mc.player == null || !MiningSpoof.mc.gameSettings.keyBindAttack.isKeyDown()) {
                return;
            }
            try {
                if (MiningSpoof.mc.world.getBlockState(MiningSpoof.mc.objectMouseOver.getBlockPos()).getBlockHardness((World)MiningSpoof.mc.world, MiningSpoof.mc.objectMouseOver.getBlockPos()) <= 0.0f) {
                    this.noPick = true;
                    return;
                }
                if (!this.shouldMineSpoof()) {
                    return;
                }
                final int pickSlot = getPickaxeSlot();
                if (pickSlot == -1) {
                    this.noPick = true;
                    return;
                }
                if (pickSlot == MiningSpoof.mc.player.inventory.currentItem) {
                    return;
                }
                this.noPick = false;
                final int oldSlot = MiningSpoof.mc.player.inventory.currentItem;
                MiningSpoof.mc.player.inventory.currentItem = pickSlot;
                MiningSpoof.mc.playerController.updateController();
                MiningSpoof.mc.player.swingArm(EnumHand.MAIN_HAND);
                MiningSpoof.mc.playerController.onPlayerDamageBlock(MiningSpoof.mc.objectMouseOver.getBlockPos(), MiningSpoof.mc.objectMouseOver.sideHit);
                MiningSpoof.mc.player.inventory.currentItem = oldSlot;
                MiningSpoof.mc.playerController.updateController();
            }
            catch (Exception ex) {}
        }, new Predicate[0]);
        this.playerDamageBlockEvent = (Listener<DamageBlockEvent>)new Listener(event -> {
            if (MiningSpoof.mc.player.inventory.currentItem != getPickaxeSlot() && !this.noPick && this.shouldMineSpoof()) {
                event.cancel();
            }
        }, new Predicate[0]);
    }
    
    protected void onDisable() {
        this.noPick = false;
    }
    
    public boolean shouldMineSpoof() {
        if (MiningSpoof.mc.objectMouseOver == null || MiningSpoof.mc.objectMouseOver.getBlockPos() == null || MiningSpoof.mc.world.getBlockState(MiningSpoof.mc.objectMouseOver.getBlockPos()).getBlock() == Blocks.AIR) {
            return false;
        }
        final Item held = MiningSpoof.mc.player.getHeldItemMainhand().getItem();
        if (((boolean)this.ignoreAxe.getValue() && held instanceof ItemAxe) || ((boolean)this.ignoreSword.getValue() && held instanceof ItemSword)) {
            return false;
        }
        final Block[] array;
        final Block[] dontMine = array = new Block[] { Blocks.WEB };
        for (final Block block : array) {
            if (block == MiningSpoof.mc.world.getBlockState(MiningSpoof.mc.objectMouseOver.getBlockPos()).getBlock()) {
                return false;
            }
        }
        return true;
    }
    
    public static int getPickaxeSlot() {
        final Item[] array;
        final Item[] picks = array = new Item[] { Items.DIAMOND_PICKAXE, Items.GOLDEN_PICKAXE, Items.IRON_PICKAXE, Items.STONE_PICKAXE, Items.WOODEN_PICKAXE };
        for (final Item pick : array) {
            if (InventoryUtil.findFirstItemSlot((Class)pick.getClass(), 0, 8) != -1) {
                return InventoryUtil.findFirstItemSlot((Class)pick.getClass(), 0, 8);
            }
        }
        return -1;
    }
    
    public static class CancelForceRotation
    {
        public static CancelForceRotation instance;
        @EventHandler
        private final Listener<PacketEvent.Send> packetEvent;
        
        public CancelForceRotation() {
            this.packetEvent = (Listener<PacketEvent.Send>)new Listener(event -> {
                if (MiningSpoof.mc.player == null) {
                    return;
                }
                if (event.getPacket() instanceof SPacketPlayerPosLook) {
                    event.cancel();
                    final SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.getPacket();
                    MiningSpoof.mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());
                    MiningSpoof.mc.player.motionY = 0.0;
                    final Vec2f rotations = RotationUtil.getRotationTo(new Vec3d((Vec3i)new BlockPos(MiningSpoof.mc.player.getPositionVector()).add(0, -1, 0)).add(0.5, 0.5, 0.5).add(new Vec3d(EnumFacing.UP.getDirectionVec()).scale(0.5)));
                    MiningSpoof.mc.player.connection.sendPacket((Packet)new CPacketConfirmTeleport(packet.getTeleportId()));
                    MiningSpoof.mc.player.connection.sendPacket((Packet)new CPacketPlayer.PositionRotation(MiningSpoof.mc.player.posX, MiningSpoof.mc.player.getEntityBoundingBox().minY, MiningSpoof.mc.player.posZ, rotations.x, rotations.y, false));
                }
            }, new Predicate[0]);
        }
        
        static {
            CancelForceRotation.instance = new CancelForceRotation();
        }
    }
}
