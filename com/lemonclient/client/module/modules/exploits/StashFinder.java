//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\user\πŸ≈¡ »≠∏È\map"!

//Decompiled by Procyon!

package com.lemonclient.client.module.modules.exploits;

import com.lemonclient.client.module.*;
import com.lemonclient.api.setting.values.*;
import net.minecraft.util.math.*;
import com.lemonclient.api.event.events.*;
import me.zero.alpine.listener.*;
import net.minecraftforge.client.event.*;
import java.util.function.*;
import com.lemonclient.api.util.misc.*;
import net.minecraft.tileentity.*;
import net.minecraft.entity.*;
import net.minecraft.entity.passive.*;
import net.minecraft.entity.item.*;
import java.text.*;
import java.io.*;
import net.minecraft.block.*;
import java.util.*;
import net.minecraft.network.play.server.*;
import net.minecraft.util.*;
import net.minecraft.init.*;
import com.mojang.realmsclient.gui.*;

@Module.Declaration(name = "StashFinder", category = Category.Exploits)
public class StashFinder extends Module
{
    BooleanSetting chest;
    IntegerSetting minchest;
    BooleanSetting echest;
    BooleanSetting shulker;
    BooleanSetting hopper;
    BooleanSetting dispenser;
    BooleanSetting dropper;
    BooleanSetting noteblock;
    BooleanSetting beacon;
    BooleanSetting donkey;
    BooleanSetting llama;
    BooleanSetting only;
    BooleanSetting chestcar;
    BooleanSetting hoppercar;
    BooleanSetting lightning;
    BooleanSetting bed;
    BooleanSetting autowalk;
    BooleanSetting chat;
    HashMap<BlockPos, Integer> chests;
    HashMap<BlockPos, Integer> shulkers;
    HashMap<BlockPos, Integer> echests;
    HashMap<BlockPos, Integer> hoppers;
    HashMap<BlockPos, Integer> dispensers;
    HashMap<BlockPos, Integer> droppers;
    HashMap<BlockPos, Integer> noteblocks;
    HashMap<BlockPos, Integer> beacons;
    ArrayList<BlockPos> countedChests;
    ArrayList<BlockPos> countedEchests;
    ArrayList<BlockPos> countedShulkers;
    ArrayList<BlockPos> countedhoppers;
    ArrayList<BlockPos> counteddispensers;
    ArrayList<BlockPos> counteddroppers;
    ArrayList<BlockPos> countednoteblocks;
    ArrayList<BlockPos> countedbeacons;
    ArrayList<BlockPos> thunders;
    ArrayList<BlockPos> donkeys;
    ArrayList<BlockPos> llamas;
    ArrayList<BlockPos> chestcars;
    ArrayList<BlockPos> hoppercars;
    ArrayList<BlockPos> beds;
    @EventHandler
    public Listener<PacketEvent.Send> listener;
    @EventHandler
    private Listener<InputUpdateEvent> inputUpdateEventListener;
    
    public StashFinder() {
        this.chest = this.registerBoolean("Chests", true);
        this.minchest = this.registerInteger("MinChestCount", 4, 0, 100);
        this.echest = this.registerBoolean("Ender Chests", true);
        this.shulker = this.registerBoolean("Shulker boxes", true);
        this.hopper = this.registerBoolean("Hoppers", true);
        this.dispenser = this.registerBoolean("Dispensers", true);
        this.dropper = this.registerBoolean("Droppers", true);
        this.noteblock = this.registerBoolean("Note Block", true);
        this.beacon = this.registerBoolean("Beacon", true);
        this.donkey = this.registerBoolean("Donkey", true);
        this.llama = this.registerBoolean("Llama", true);
        this.only = this.registerBoolean("Only Owned", true);
        this.chestcar = this.registerBoolean("Chest Minecart", true);
        this.hoppercar = this.registerBoolean("Hopper Minecart", true);
        this.lightning = this.registerBoolean("Thunders", false);
        this.bed = this.registerBoolean("Bed", true);
        this.autowalk = this.registerBoolean("AutoWalk", false);
        this.chat = this.registerBoolean("Send Message", true);
        this.chests = new HashMap<BlockPos, Integer>();
        this.shulkers = new HashMap<BlockPos, Integer>();
        this.echests = new HashMap<BlockPos, Integer>();
        this.hoppers = new HashMap<BlockPos, Integer>();
        this.dispensers = new HashMap<BlockPos, Integer>();
        this.droppers = new HashMap<BlockPos, Integer>();
        this.noteblocks = new HashMap<BlockPos, Integer>();
        this.beacons = new HashMap<BlockPos, Integer>();
        this.countedChests = new ArrayList<BlockPos>();
        this.countedEchests = new ArrayList<BlockPos>();
        this.countedShulkers = new ArrayList<BlockPos>();
        this.countedhoppers = new ArrayList<BlockPos>();
        this.counteddispensers = new ArrayList<BlockPos>();
        this.counteddroppers = new ArrayList<BlockPos>();
        this.countednoteblocks = new ArrayList<BlockPos>();
        this.countedbeacons = new ArrayList<BlockPos>();
        this.thunders = new ArrayList<BlockPos>();
        this.donkeys = new ArrayList<BlockPos>();
        this.llamas = new ArrayList<BlockPos>();
        this.chestcars = new ArrayList<BlockPos>();
        this.hoppercars = new ArrayList<BlockPos>();
        this.beds = new ArrayList<BlockPos>();
        this.listener = (Listener<PacketEvent.Send>)new Listener(event -> {
            final BlockPos pos = null;
            if ((boolean)this.lightning.getValue() && event.getPacket() instanceof SPacketSoundEffect) {
                final SPacketSoundEffect packet = (SPacketSoundEffect)event.getPacket();
                if (packet.getCategory() == SoundCategory.WEATHER && packet.getSound() == SoundEvents.ENTITY_LIGHTNING_THUNDER) {
                    pos.add(packet.getX(), packet.getY(), packet.getZ());
                    this.thunders.add(pos);
                    if (this.chat.getValue()) {
                        MessageBus.sendClientPrefixMessage(ChatFormatting.GOLD + "Lightning spawned at X" + packet.getX() + " Z" + packet.getZ());
                    }
                }
            }
        }, new Predicate[0]);
        this.inputUpdateEventListener = (Listener<InputUpdateEvent>)new Listener(event -> {
            if ((boolean)this.autowalk.getValue() && StashFinder.mc.player != null) {
                event.getMovementInput().moveForward = 1.0f;
            }
        }, new Predicate[0]);
    }
    
    public void onUpdate() {
        int ccount = 0;
        int ecount = 0;
        int scount = 0;
        int hcount = 0;
        int dicount = 0;
        int drcount = 0;
        int ncount = 0;
        int bcount = 0;
        for (final TileEntity tileEntity : StashFinder.mc.world.loadedTileEntityList) {
            final BlockPos pos = tileEntity.getPos();
            if (tileEntity instanceof TileEntityChest && !this.chests.containsKey(pos) && !this.countedChests.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.CHEST) {
                        this.countedChests.add(blockPos);
                        ++ccount;
                    }
                }
                if (ccount >= (int)this.minchest.getValue()) {
                    this.chests.put(pos, ccount);
                    if ((boolean)this.chat.getValue() && (boolean)this.chest.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + ccount + "x chest at " + this.getFormattedBlockPos(pos));
                    }
                }
                ccount = 0;
            }
            if (tileEntity instanceof TileEntityEnderChest && !this.echests.containsKey(pos) && !this.countedEchests.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.ENDER_CHEST) {
                        this.countedEchests.add(blockPos);
                        ++ecount;
                    }
                }
                if (ecount >= 1) {
                    this.echests.put(pos, ecount);
                    if ((boolean)this.chat.getValue() && (boolean)this.echest.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + ecount + "x echest at " + this.getFormattedBlockPos(pos));
                    }
                }
                ecount = 0;
            }
            if (tileEntity instanceof TileEntityShulkerBox && !this.shulkers.containsKey(pos) && !this.countedShulkers.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (this.isShulkerBox(blockPos)) {
                        this.countedShulkers.add(blockPos);
                        ++scount;
                    }
                }
                if (scount >= 1) {
                    this.shulkers.put(pos, scount);
                    if ((boolean)this.chat.getValue() && (boolean)this.shulker.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + scount + "x shulker at " + this.getFormattedBlockPos(pos));
                    }
                }
                scount = 0;
            }
            if (tileEntity instanceof TileEntityBed && !this.beds.contains(pos)) {
                this.beds.add(pos);
                if ((boolean)this.chat.getValue() && (boolean)this.bed.getValue()) {
                    MessageBus.sendClientPrefixMessage("Found a bed at" + pos);
                }
            }
            if (tileEntity instanceof TileEntityHopper && !this.hoppers.containsKey(pos) && !this.countedhoppers.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.HOPPER) {
                        this.countedhoppers.add(blockPos);
                        ++hcount;
                    }
                }
                if (hcount >= 1) {
                    this.hoppers.put(pos, hcount);
                    if ((boolean)this.chat.getValue() && (boolean)this.hopper.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + hcount + "x hopper at " + this.getFormattedBlockPos(pos));
                    }
                }
                hcount = 0;
            }
            if (tileEntity instanceof TileEntityDispenser && !this.dispensers.containsKey(pos) && !this.counteddispensers.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.DISPENSER) {
                        this.counteddispensers.add(blockPos);
                        ++dicount;
                    }
                }
                if (dicount >= 1) {
                    this.dispensers.put(pos, dicount);
                    if ((boolean)this.chat.getValue() && (boolean)this.dispenser.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + dicount + "x dispenser at " + this.getFormattedBlockPos(pos));
                    }
                }
                dicount = 0;
            }
            if (tileEntity instanceof TileEntityDropper && !this.droppers.containsKey(pos) && !this.counteddroppers.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.DROPPER) {
                        this.counteddroppers.add(blockPos);
                        ++drcount;
                    }
                }
                if (drcount >= 1) {
                    this.droppers.put(pos, drcount);
                    if ((boolean)this.chat.getValue() && (boolean)this.dropper.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + drcount + "x dropper at " + this.getFormattedBlockPos(pos));
                    }
                }
                drcount = 0;
            }
            if (tileEntity instanceof TileEntityNote && !this.noteblocks.containsKey(pos) && !this.countednoteblocks.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.NOTEBLOCK) {
                        this.countednoteblocks.add(blockPos);
                        ++ncount;
                    }
                }
                if (ncount >= 1) {
                    this.noteblocks.put(pos, ncount);
                    if ((boolean)this.chat.getValue() && (boolean)this.noteblock.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + ncount + "x note block at " + this.getFormattedBlockPos(pos));
                    }
                }
                ncount = 0;
            }
            if (tileEntity instanceof TileEntityBeacon && !this.beacons.containsKey(pos) && !this.countedbeacons.contains(pos)) {
                final Iterable<BlockPos> posIterable = (Iterable<BlockPos>)BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (StashFinder.mc.world.getBlockState(blockPos).getBlock() == Blocks.BEACON) {
                        this.countedbeacons.add(blockPos);
                        ++bcount;
                    }
                }
                if (bcount >= 1) {
                    this.beacons.put(pos, bcount);
                    if ((boolean)this.chat.getValue() && (boolean)this.beacon.getValue()) {
                        MessageBus.sendClientPrefixMessage("Found " + bcount + "x beacon at " + this.getFormattedBlockPos(pos));
                    }
                }
                bcount = 0;
            }
        }
        for (final Entity entity : StashFinder.mc.world.loadedEntityList) {
            final BlockPos pos2 = entity.getPosition();
            if (entity instanceof EntityDonkey && !this.donkeys.contains(pos2)) {
                this.donkeys.add(pos2);
                if (!(boolean)this.chat.getValue() || !(boolean)this.donkey.getValue() || ((boolean)this.only.getValue() && ((EntityDonkey)entity).getOwnerUniqueId() == null)) {
                    continue;
                }
                MessageBus.sendClientPrefixMessage("Found a donkey at" + pos2);
            }
        }
        for (final Entity entity : StashFinder.mc.world.loadedEntityList) {
            final BlockPos pos2 = entity.getPosition();
            if (entity instanceof EntityLlama && !this.llamas.contains(pos2)) {
                this.llamas.add(pos2);
                if (!(boolean)this.chat.getValue() || !(boolean)this.llama.getValue() || ((boolean)this.only.getValue() && ((EntityLlama)entity).getOwnerUniqueId() == null)) {
                    continue;
                }
                MessageBus.sendClientPrefixMessage("Found a llama at" + pos2);
            }
        }
        for (final Entity entity : StashFinder.mc.world.loadedEntityList) {
            final BlockPos pos2 = entity.getPosition();
            if (entity instanceof EntityMinecartChest && !this.chestcars.contains(pos2)) {
                this.chestcars.add(pos2);
                if (!(boolean)this.chat.getValue() || !(boolean)this.chestcar.getValue()) {
                    continue;
                }
                MessageBus.sendClientPrefixMessage("Found a Chest Minecart at" + pos2);
            }
        }
        for (final Entity entity : StashFinder.mc.world.loadedEntityList) {
            final BlockPos pos2 = entity.getPosition();
            if (entity instanceof EntityMinecartHopper && !this.hoppercars.contains(pos2)) {
                this.hoppercars.add(pos2);
                if (!(boolean)this.chat.getValue() || !(boolean)this.hoppercar.getValue()) {
                    continue;
                }
                MessageBus.sendClientPrefixMessage("Found a Hopper Minecart at" + pos2);
            }
        }
    }
    
    public void onDisable() {
        try {
            final DateFormat df = new SimpleDateFormat("yy-MM-dd");
            final DateFormat df2 = new SimpleDateFormat("HH-mm");
            final Date date = new Date();
            final Date date2 = new Date();
            final File file = new File("OuO/StashFinder/" + df.format(date) + " " + df2.format(date2) + ".txt");
            if (!file.exists()) {
                file.getParentFile().mkdirs();
                try {
                    file.createNewFile();
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
            final FileOutputStream fop = new FileOutputStream(file);
            final OutputStreamWriter writer = new OutputStreamWriter(fop);
            final Writer writer2;
            this.thunders.forEach(blockPos -> {
                try {
                    if (this.lightning.getValue()) {
                        writer2.append((CharSequence)"Thunder spawned at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex) {}
                return;
            });
            final Writer writer3;
            this.beds.forEach(blockPos -> {
                try {
                    if (this.bed.getValue()) {
                        writer3.append((CharSequence)"bed at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex2) {}
                return;
            });
            final Writer writer4;
            this.chests.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.chest.getValue() && integer >= (int)this.minchest.getValue()) {
                        writer4.append((CharSequence)integer.toString()).append((CharSequence)"x chest at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex3) {}
                return;
            });
            final Writer writer5;
            this.echests.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.echest.getValue() && integer >= 1) {
                        writer5.append((CharSequence)integer.toString()).append((CharSequence)"x echest at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex4) {}
                return;
            });
            final Writer writer6;
            this.shulkers.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.shulker.getValue() && integer >= 1) {
                        writer6.append((CharSequence)integer.toString()).append((CharSequence)"x shulker at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex5) {}
                return;
            });
            final Writer writer7;
            this.hoppers.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.hopper.getValue() && integer >= 1) {
                        writer7.append((CharSequence)integer.toString()).append((CharSequence)"x hopper at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex6) {}
                return;
            });
            final Writer writer8;
            this.dispensers.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.dispenser.getValue() && integer >= 1) {
                        writer8.append((CharSequence)integer.toString()).append((CharSequence)"x dispenser at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex7) {}
                return;
            });
            final Writer writer9;
            this.droppers.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.dropper.getValue() && integer >= 1) {
                        writer9.append((CharSequence)integer.toString()).append((CharSequence)"x dropper at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex8) {}
                return;
            });
            final Writer writer10;
            this.noteblocks.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.noteblock.getValue() && integer >= 1) {
                        writer10.append((CharSequence)integer.toString()).append((CharSequence)"x noteblock at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex9) {}
                return;
            });
            final Writer writer11;
            this.beacons.forEach((blockPos, integer) -> {
                try {
                    if ((boolean)this.beacon.getValue() && integer >= 1) {
                        writer11.append((CharSequence)integer.toString()).append((CharSequence)"x beacon at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex10) {}
                return;
            });
            final Writer writer12;
            this.donkeys.forEach(blockPos -> {
                try {
                    if (this.donkey.getValue()) {
                        writer12.append((CharSequence)"donkey at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex11) {}
                return;
            });
            final Writer writer13;
            this.chestcars.forEach(blockPos -> {
                try {
                    if (this.chestcar.getValue()) {
                        writer13.append((CharSequence)"chest minecart at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex12) {}
                return;
            });
            final Writer writer14;
            this.hoppercars.forEach(blockPos -> {
                try {
                    if (this.hoppercar.getValue()) {
                        writer14.append((CharSequence)"hopper minecart at ").append((CharSequence)this.getFormattedBlockPos(blockPos)).append((CharSequence)"\n");
                    }
                }
                catch (IOException ex13) {}
                return;
            });
            writer.close();
            fop.close();
            MessageBus.sendClientPrefixMessage("File output succeed");
        }
        catch (IOException e2) {
            MessageBus.sendClientPrefixMessage("File output exception:" + e2);
        }
        finally {
            this.beds.clear();
            this.chests.clear();
            this.donkeys.clear();
            this.shulkers.clear();
            this.echests.clear();
            this.hoppers.clear();
            this.dispensers.clear();
            this.droppers.clear();
            this.noteblocks.clear();
            this.beacons.clear();
            this.countedEchests.clear();
            this.countedShulkers.clear();
            this.countedChests.clear();
            this.countedhoppers.clear();
            this.counteddispensers.clear();
            this.counteddroppers.clear();
            this.countednoteblocks.clear();
            this.countedbeacons.clear();
        }
    }
    
    private String getFormattedBlockPos(final BlockPos blockPos) {
        String done = blockPos.toString().replaceAll("BlockPos\\{", "");
        done = done.replaceAll("}", "");
        done = done.replaceAll("=", "= ");
        return done;
    }
    
    private Boolean isShulkerBox(final BlockPos blockPos) {
        final List<Block> shulkerList = Arrays.asList(Blocks.WHITE_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.SILVER_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.BLACK_SHULKER_BOX);
        return shulkerList.contains(StashFinder.mc.world.getBlockState(blockPos).getBlock());
    }
}
